#+TITLE: promptivd
#+AUTHOR: Miguel Guedes <miguel@softgeist.com>
#+DATE: 14/09/2025
#+OPTIONS: toc:2 num:nil ^:nil

* Overview

A high-performance Rust daemon that relays /insert/ text jobs from local clients to connected sinks over WebSocket. Sinks implement the actual insertion logic; one example of which is the [[https://github.com/midsbie/promptive][promptive browser extension]].

** Features
- Built atop Tokio and axum with structured tracing and graceful shutdown.
- Immediate dispatch with sink ACK propagation and comprehensive error handling.
- Clean modular architecture following SRP.
- Structured logging, health checks, and WebSocket heartbeat supervision.
- Provider introspection via =GET /v1/providers= so clients can tailor UX to the active sink.
- Includes a sample CLI client (promptivc) and sink (promptivs) illustrating end-to-end relay and acknowledgment flow.

* Architecture
#+BEGIN_SRC
[Client] -- HTTP --> [Relay Handler] == WS ==> [Extension Sink] --> [Provider Adapter] --> Sink action
#+END_SRC

* API Endpoints

** HTTP API

*** POST /v1/insert
Submit an insert-text job.

Accepts a JSON payload describing the text snippet, origin metadata, optional placement hints, and an optional target specification. Validates input and relays to an active sink. Returns the sink’s ACK on success, or an error if validation fails or no sink is available.

**** Request Payload
Body is a JSON object matching the structures below.

=Content-Type: application/json=

#+BEGIN_SRC json
{
  "schema_version": "1.0",
  "source": {
    "client": "string (non-empty)",
    "label": "string | null",
    "path": "string | null"
  },
  "text": "string (non-empty after trim)",
  "placement": {
    "type": "top" | "bottom" | "cursor"
  } | null,
  "target": {
    "provider": "string | null",
    "session_policy": "reuse_or_create" | "reuse_only" | "start_fresh" | null
  } | null,
  "metadata": {
    "...": "..."
  } | null
}
#+END_SRC

- *placement*: optional hint for where the snippet should be inserted if the sink supports multiple insertion modes.
- *target*: optional structured directive. A non-empty *provider* string aligns with a provider ID advertised by the sink. *session_policy* guides how the sink should reuse or create sessions (=REUSE_OR_CREATE= by default, =REUSE_ONLY= to fail if reuse is impossible, =START_FRESH= to force a new session).
- *metadata*: optional arbitrary JSON provided by the client (e.g., timestamps, originating editor context). When omitted, downstream frames omit the field entirely.

**** Responses
- =200 OK=: job delivered. Response body contains ={"job_id":"...","status":"ok"}=.
- =502 Bad Gateway=: sink responded with =retry= or =failed=. Body includes the sink’s status and optional error text.
- =503 Service Unavailable=: no sink is connected (or =require_sink=true= prevented queuing). Clients should retry later.
- =400 Bad Request=: schema validation or serialization failure.
- =413 Payload Too Large=: payload exceeds =server.max_job_bytes=.

If =server.require_sink=true= (default =false=), the daemon rejects jobs immediately when no sink is connected. Otherwise jobs are attempted and fail with 503 only when dispatch is impossible.

*** GET /v1/providers
Return the list of provider identifiers advertised by the currently registered sink.

**** Responses
- =200 OK= with body:

#+BEGIN_SRC json
{"providers": ["chatgpt", "claude"]}
#+END_SRC

- =503 Service Unavailable=: no sink is connected. This mirrors =AppError::NoSink= and signals clients to fall back to default behaviour.

*** GET /v1/health
Lightweight liveness probe. Returns a JSON object with daemon status, current timestamp, and version string.

** WebSocket

*** GET /v1/sink/ws
WebSocket endpoint for sinks.

Upgrades to a persistent WebSocket connection used by the sink. The server relays validated insert-text jobs to the connected sink and expects ACKs/heartbeats to maintain session health.

**** Registration handshake
Immediately after connecting, the sink must send a =register= frame:

#+BEGIN_SRC json
{
  "type": "register",
  "schema_version": "1.0",
  "version": "sink-version",
  "capabilities": ["insert"],
  "providers": ["chatgpt", "claude"]
}
#+END_SRC

- *capabilities*: feature flags; today ="insert"= indicates support for insert-text jobs. Additional capabilities may be introduced later.
- *providers*: sink-specific provider identifiers. As an example, for a browser extension sink these would typically map to supported web interfaces; e.g. =chatgpt=, =claude=, or =gemini=. An empty list is valid for sinks that do not integrate with provider-specific flows.

Upon successful registration the daemon responds with a =policy= frame describing limits. Clients can surface the advertised providers to users when constructing =target= directives.

**** Policy frame
The relay acknowledges registration with a =policy= message that communicates limits derived from configuration:

#+BEGIN_SRC json
{
  "type": "policy",
  "schema_version": "1.0",
  "supersede_on_register": true,
  "max_job_bytes": 131072
}
#+END_SRC

- *supersede_on_register*: whether a new sink replaces the current connection.
- *max_job_bytes*: upper bound enforced on incoming HTTP payloads.

**** Heartbeats
Once registered, the relay emits =ping= frames every =server.websocket_ping_interval= seconds. The sink must reply with =pong= within =server.websocket_pong_timeout=, otherwise missed pings are counted until =server.websocket_max_missed_pings= triggers disconnect and pending jobs are retried.

**** Insert-text jobs
Validated jobs are delivered as =insert_text= messages:

#+BEGIN_SRC json
{
  "type": "insert_text",
  "schema_version": "1.0",
  "id": "job-uuid",
  "payload": {
    "text": "snippet",
    "placement": {"type": "cursor"} | null,
    "source": {"client": "cli", "label": "CLI", "path": "/tmp/file"},
    "target": {"provider": "chatgpt", "session_policy": "start_fresh"} | null,
    "metadata": {"timestamp": "...", "extra": "..."} | null
  }
}
#+END_SRC

The sink must process the payload, perform the insertion, and reply with an =ack= frame (=status= = =ok=, =retry=, or =failed=).

* Sample CLI Client (promptivc)
A minimal HTTP client used to submit /insert/ text jobs to the daemon. It demonstrates how a local tool can package a snippet, attach source metadata, and dispatch it through =POST /v1/insert=. Serves as a reference for integrating editors, scripts, or other automation with the relay.

Run:
#+BEGIN_SRC shell
cargo run --bin promptivc -- --help
#+END_SRC

* Sample Sink Client (promptivs)
A minimal WebSocket sink used to receive jobs from the daemon. It illustrates how a sink maintains a live connection on =/v1/sink/ws=, processes incoming insert-text requests, and returns ACKs.

Run:
#+BEGIN_SRC shell
cargo run --bin promptivs -- --help
#+END_SRC

* Configuration
The daemon loads configuration from =~/.config/promptivd/config.yaml= (or =promptivd.yaml= in the working directory), with environment overrides prefixed by =PROMPTIVD_=. Key server settings:
- =server.bind_addr=: listen address (default =127.0.0.1:8787=).
- =server.require_sink=: whether HTTP ingress requires an active sink before accepting jobs.
- =server.supersede_on_register=: replace the current sink automatically when a new one registers.
- =server.max_job_bytes=: maximum serialized request size (default 128 KiB).
- =server.websocket_ping_interval=: interval between relay ping frames (seconds).
- =server.websocket_pong_timeout=: grace period for pong responses (seconds).
- =server.websocket_max_missed_pings=: consecutive missed pongs before disconnect.
- =server.dispatch_timeout=: maximum time to wait for sink ACKs before timing out the HTTP request.

Run =cargo run --bin promptivd -- --init-config= to scaffold the default configuration file with these values.

* License
Distributed under the MIT License. See LICENSE for more information.
